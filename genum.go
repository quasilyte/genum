package genum

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"runtime"
	"strings"
	"text/template"
	"unicode/utf8"
)

type Generator struct {
	TypeName string

	PackageName string

	ValueExpr ValueKind

	Flags Flags

	underlyingType string
	loc            string
}

type Flags int

const (
	FlagExtraFmtBinary Flags = 1 << iota
	FlagExtraFmtHex
)

type ValueKind int

const (
	// ValueIota is `= iota` expression
	ValueIota ValueKind = iota
)

type EnumEntry struct {
	Name    string
	String  string
	Comment []string
}

type enumEntryData struct {
	Name       string
	StringFrom int
	StringTo   int
	String     string
	Comment    string
}

func NewGenerator() *Generator {
	_, file, line, ok := runtime.Caller(1)
	if !ok {
		panic("failed to extract caller information")
	}
	g := &Generator{}
	g.loc = fmt.Sprintf("%s:%d", file, line)
	return g
}

func (g *Generator) SetUnderlyingType(typeName string) {
	switch typeName {
	case "int", "int8", "int16", "int32", "int64":
		// OK
	case "uint", "uint8", "uint16", "uint32", "uint64":
		// OK
	default:
		panic(fmt.Sprintf("unexpected underlying type: %q", typeName))
	}
	g.underlyingType = typeName
}

func (g *Generator) Generate(w io.Writer, entries []EnumEntry) {
	var incFunc func(i int64) int64
	var valueExpr string
	switch g.ValueExpr {
	case ValueIota:
		valueExpr = "iota"
		incFunc = func(i int64) int64 {
			return i + 1
		}
	}

	var combinedStringBuilder strings.Builder
	valueMapping := [][2]int{}
	{
		offset := 0
		for _, e := range entries {
			s := e.String
			if s == "" {
				s = e.Name
			}
			combinedStringBuilder.WriteString(s)
			valueMapping = append(valueMapping, [2]int{offset, offset + len(s)})
			offset += len(s)
		}
	}

	combinedString := combinedStringBuilder.String()

	values := make([]enumEntryData, len(entries))
	{
		currentValue := int64(0)
		for i, e := range entries {
			var commentLines []string
			for _, l := range e.Comment {
				commentLines = append(commentLines, "// "+l)
			}
			{
				valueString := fmt.Sprintf("// Value=%d", currentValue)
				if g.Flags&FlagExtraFmtHex != 0 {
					valueString += fmt.Sprintf(" hex=`%x`", currentValue)
				}
				if g.Flags&FlagExtraFmtBinary != 0 {
					valueString += fmt.Sprintf(" bin=`%b`", currentValue)
				}
				commentLines = append(commentLines, valueString)
			}
			fromTo := valueMapping[i]
			values[i] = enumEntryData{
				Name:       e.Name,
				StringFrom: fromTo[0],
				StringTo:   fromTo[1],
				String:     combinedString[fromTo[0]:fromTo[1]],
				Comment:    strings.Join(commentLines, "\n"),
			}
			currentValue = incFunc(currentValue)
		}
	}

	firstChar, _ := utf8.DecodeRuneInString(g.TypeName)
	data := map[string]any{
		"PackageName":    g.PackageName,
		"TypeName":       g.TypeName,
		"UnderlyingType": g.underlyingType,
		"NumValues":      len(values),
		"ValueExpr":      valueExpr,
		"FirstValue":     values[0],
		"Values":         values[1:],
		"AllValues":      values,
		"ReceiverName":   strings.ToLower(string(firstChar)),
		"CombinedString": combinedString,
		"Loc":            g.loc,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		panic(err)
	}

	pretty, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	w.Write(pretty)
}

var tmpl = template.Must(template.New("genum").Parse(`// Code generated by genum, DO NOT EDIT.
// Generator location: {{.Loc}}

package {{$.PackageName}}

const Num{{$.TypeName}} = {{$.NumValues}}

const (
	{{.FirstValue.Comment}}
	{{.FirstValue.Name}} {{$.TypeName}} = {{$.ValueExpr}}

	{{range $.Values}}
		{{.Comment}}
		{{.Name}} {{$.UnderlyingType}}
	{{end}}
)

const _{{$.TypeName}}_string = "{{$.CombinedString}}"

// String returns the text-printed representation of {{$.TypeName}}.
// Can be used for serialization.
//
// Returns an empty string for unknown enum entries.
func ({{$.ReceiverName}} {{$.TypeName}}) String() string {
	switch ({{$.ReceiverName}}) {
	{{range $.AllValues -}}
	case {{.Name}}:
		return _{{$.TypeName}}_string[{{.StringFrom}}:{{.StringTo}}] // "{{.String}}"
	{{end -}}
	}
	return ""
}

// FromString updates the {{$.ReceiverName}} value if given string is recognized.
// Can be used for deserialization if the values for FromString are created by String method.
//
// Keeps the old value if given string is not recognized.
func ({{$.ReceiverName}} *{{$.TypeName}}) FromString(raw string) {
	value := *{{$.ReceiverName}}
	switch raw {
	{{range $.AllValues -}}
	case "{{.String}}":
		value = {{.Name}}
	{{end -}}
	}
	*{{$.ReceiverName}} = value
}
`))
