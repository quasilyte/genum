package genum

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"runtime"
	"strings"
	"text/template"
	"unicode/utf8"
)

type Generator struct {
	typeName string

	packageName string

	valueExpr valueExprKind

	loc string
}

type valueExprKind int

const (
	valueExprIota valueExprKind = iota
)

type parsedEnumEntry struct {
	Name   string
	String string
}

type enumEntryData struct {
	Name       string
	StringFrom int
	StringTo   int
	String     string
}

func NewGenerator(packageName, typeName string) *Generator {
	_, file, line, ok := runtime.Caller(1)
	if !ok {
		panic("failed to extract caller information")
	}
	g := &Generator{
		packageName: packageName,
		typeName:    typeName,
	}
	g.loc = fmt.Sprintf("%s:%d", file, line)
	return g
}

func (g *Generator) analyzeValueExpr(e ast.Expr) {
	switch e := e.(type) {
	case *ast.ParenExpr:
		g.analyzeValueExpr(e.X)
	case *ast.Ident:
		g.valueExpr = valueExprIota
	default:
		panic(fmt.Sprintf("unexpected expr: %T", e))
	}
}

func (g *Generator) matchDecl(decl *ast.GenDecl) bool {
	if len(decl.Specs) == 0 {
		return false
	}

	spec, ok := decl.Specs[0].(*ast.ValueSpec)
	if !ok {
		return false
	}
	if len(spec.Names) != 1 || len(spec.Values) != 1 || spec.Type == nil {
		return false
	}

	hasIota := false
	ast.Inspect(spec.Values[0], func(n ast.Node) bool {
		if ident, ok := n.(*ast.Ident); ok {
			if ident.Name == "iota" {
				hasIota = true
				return false
			}
		}
		return true
	})
	if !hasIota {
		return false
	}

	typeIdent, ok := spec.Type.(*ast.Ident)
	if !ok {
		return false
	}
	if typeIdent.Name != g.typeName {
		return false
	}

	for _, spec := range decl.Specs[1:] {
		spec, ok := spec.(*ast.ValueSpec)
		if !ok {
			return false
		}
		if len(spec.Values) != 0 || len(spec.Names) != 1 || spec.Type != nil {
			return false
		}
	}

	return true
}

func (g *Generator) Generate(w io.Writer, filename string, src []byte) {
	var entries []parsedEnumEntry

	var parserSource any
	if src != nil {
		parserSource = src
	}

	f, err := parser.ParseFile(token.NewFileSet(), filename, parserSource, parser.ParseComments)
	if err != nil {
		panic(fmt.Sprintf("parsing %q: %v", filename, err))
	}

	for _, decl := range f.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if decl.Tok != token.CONST {
			continue
		}
		if !g.matchDecl(decl) {
			continue
		}

		firstSpec := decl.Specs[0].(*ast.ValueSpec)
		g.analyzeValueExpr(firstSpec.Values[0])

		for _, spec := range decl.Specs {
			spec := spec.(*ast.ValueSpec)
			name := spec.Names[0].Name
			s := name
			if spec.Comment != nil && len(spec.Comment.List) == 1 {
				s = strings.TrimSpace(strings.TrimPrefix(spec.Comment.List[0].Text, "//"))
			}
			e := parsedEnumEntry{
				Name:   name,
				String: s,
			}
			entries = append(entries, e)
		}
	}

	if len(entries) == 0 {
		return
	}

	g.generate(w, entries)
}

func (g *Generator) generate(w io.Writer, entries []parsedEnumEntry) {
	var combinedStringBuilder strings.Builder
	valueMapping := [][2]int{}
	{
		offset := 0
		for _, e := range entries {
			s := e.String
			if s == "" {
				s = e.Name
			}
			combinedStringBuilder.WriteString(s)
			valueMapping = append(valueMapping, [2]int{offset, offset + len(s)})
			offset += len(s)
		}
	}

	combinedString := combinedStringBuilder.String()

	values := make([]enumEntryData, len(entries))
	{
		for i, e := range entries {
			fromTo := valueMapping[i]
			values[i] = enumEntryData{
				Name:       e.Name,
				StringFrom: fromTo[0],
				StringTo:   fromTo[1],
				String:     combinedString[fromTo[0]:fromTo[1]],
			}
		}
	}

	firstChar, _ := utf8.DecodeRuneInString(g.typeName)
	data := map[string]any{
		"PackageName":    g.packageName,
		"TypeName":       g.typeName,
		"NumValues":      len(values),
		"Values":         values,
		"FirstValue":     values[0],
		"LastValue":      values[len(values)-1],
		"ReceiverName":   strings.ToLower(string(firstChar)),
		"CombinedString": combinedString,
		"Loc":            g.loc,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		panic(err)
	}

	pretty, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	w.Write(pretty)
}

var tmpl = template.Must(template.New("genum").Parse(`// Code generated by genum, DO NOT EDIT.
// Generator location: {{.Loc}}

package {{$.PackageName}}

const Num{{$.TypeName}} = {{$.NumValues}}

const _{{$.TypeName}}_string = "{{$.CombinedString}}"

// FirstValue returns the lowest {{$.TypeName}} enum value.
// Useful for iteration and bound checks.
func ({{$.ReceiverName}} {{$.TypeName}}) FirstValue() {{$.TypeName}} {
	return {{$.FirstValue.Name}}
}

// LastValue returns the highest {{$.TypeName}} enum value.
// Useful for iteration and bound checks.
func ({{$.ReceiverName}} {{$.TypeName}}) LastValue() {{$.TypeName}} {
	return {{$.LastValue.Name}}
}

// String returns the text-printed representation of {{$.TypeName}}.
// Can be used for serialization.
//
// Returns an empty string for unknown enum entries.
func ({{$.ReceiverName}} {{$.TypeName}}) String() string {
	switch ({{$.ReceiverName}}) {
	{{range $.Values -}}
	case {{.Name}}:
		return _{{$.TypeName}}_string[{{.StringFrom}}:{{.StringTo}}] // "{{.String}}"
	{{end -}}
	}
	return ""
}

// AssignString updates the {{$.ReceiverName}} value if given string is recognized.
// Can be used for deserialization if the values for AssignString are created by String method.
//
// Keeps the old value if given string is not recognized.
func ({{$.ReceiverName}} *{{$.TypeName}}) AssignString(raw string) {
	value := *{{$.ReceiverName}}
	switch raw {
	{{range $.Values -}}
	case "{{.String}}":
		value = {{.Name}}
	{{end -}}
	}
	*{{$.ReceiverName}} = value
}
`))
